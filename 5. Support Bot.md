# Support Bot

Over the last few notebooks, you've assembled a powerful toolkit for automation. You've mastered creating and managing asynchronous tasks, handling file uploads, building event-driven workflows with webhooks, and integrating it all into a conversational Slack bot.

Now, it's time to combine these skills to build a practical, end-to-end solution that solves a real-world business problem: automating employee vacation claims.

In this notebook, we will create an intelligent support bot that lives in Slack. 

Employees will be able to submit their vacation expense claims by simply uploading a receipt and mentioning the bot. From there, our system will take over, using Manus to intelligently process the document and automatically add a structured entry into a central Notion database for the finance team to review.


## Supporting File Uplaods

Now that we have our basic Slack integration working, let's enhance it to handle file attachments. When employees submit support requests or vacation claims, they often need to include supporting documents like receipts, medical certificates, or authorization forms.

### Understanding Slack File Events

When a user mentions your bot with file attachments, Slack sends additional file information in the webhook payload. Let's first examine the structure of these events and then modify our server to process them.


```python
import json

# Example of what a file attachment event looks like
file_event_example = {
    "type": "event_callback",
    "event": {
        "type": "app_mention",
        "user": "U1234567890",
        "text": "<@U09U5R59FDL> I need to submit my vacation claim with attached receipt",
        "ts": "1678886400.123456",
        "channel": "C09U5STV0FQ",
        "files": [
            {
                "id": "F1234567890",
                "name": "vacation_receipt.pdf",
                "mimetype": "application/pdf",
                "url_private": "https://files.slack.com/files-pri/T1234567890-F1234567890/vacation_receipt.pdf",
                "size": 123456
            }
        ]
    }
}

print("File event structure:")
print(json.dumps(file_event_example, indent=2))
```

**Output:**

```
File event structure:
{
  "type": "event_callback",
  "event": {
    "type": "app_mention",
    "user": "U1234567890",
    "text": "<@U09U5R59FDL> I need to submit my vacation claim with attached receipt",
    "ts": "1678886400.123456",
    "channel": "C09U5STV0FQ",
    "files": [
      {
        "id": "F1234567890",
        "name": "vacation_receipt.pdf",
        "mimetype": "application/pdf",
        "url_private": "https://files.slack.com/files-pri/T1234567890-F1234567890/vacation_receipt.pdf",
        "size": 123456
      }
    ]
  }
}
```

In this section, we will upgrade our bot to handle file attachments, creating a seamless workflow where employees can simply upload a file and mention the bot to kick off the entire process.

Let's start by adding a simple function here to upload our files to the Manus API.

```py
class FileIDAttachment(TypedDict):
    """Defines the structure for a File ID attachment for the Manus API."""
    file_id: str
    filename: str
    
import requests
import os
def upload_file_to_manus(file_content: bytes, filename: str) -> str:
    """
    Uploads a file to the Manus workspace and returns its file_id.
    """
    api_key = os.environ["MANUS_API_KEY"]
    base_url = "https://api.manus.ai/v1"

    # Step 1: Create a file record and get a presigned upload URL
    headers = {"API_KEY": api_key, "Content-Type": "application/json"}
    create_file_response = requests.post(
        f"{base_url}/files",
        headers=headers,
        json={"filename": filename}
    )
    create_file_response.raise_for_status()
    file_record = create_file_response.json()
    
    file_id = file_record["id"]
    upload_url = file_record["upload_url"]
    print(f"✓ File record created for '{filename}'. File ID: {file_id}")

    # Step 2: Upload the file content to the presigned URL
    upload_response = requests.put(
        upload_url,
        data=file_content,
        headers={"Content-Type": "application/octet-stream"} # Use octet-stream for raw bytes
    )
    upload_response.raise_for_status()
    
    print(f"✓ File '{filename}' uploaded successfully!")
    return file_id
```
Finally, let's integrate this into our main handle_slack_message function. The new logic checks the Slack event for a files array. If files are present, it downloads each one and uses our new helper to upload it to Manus, collecting the file_ids to attach to our task.

```py
def handle_slack_message(event: AppMentionEvent) -> None:
    """
    Handles Slack mentions, now with logic to process file attachments via the Files API.
    """
    channel_id = event["channel"]
    thread_id = event.get("thread_ts", event["ts"])
    
    raw_text = event.get("text", "")
    prompt_text = re.sub(r"^<@[\w\d]+>\s*", "", raw_text)

    client = get_slack_client()
    
    existing_task_id = thread_task_map.get(thread_id)
    
    
    manus_attachments: List[FileIDAttachment] = []
    if "files" in event:
        print(f"Found {len(event['files'])} files in the Slack message.")
        for file in event["files"]:
            file_url = file["url_private_download"]
            file_name = file["name"]
            
            # Download the file using the authenticated Slack URL
            response = requests.get(
                file_url,
                headers={"Authorization": f"Bearer {os.environ['SLACK_BOT_TOKEN']}"}
            )
            response.raise_for_status()
            
            # Upload the file to Manus and get the file_id
            file_id = upload_file_to_manus(response.content, file_name)
            
            # Prepare the attachment for the Manus task
            manus_attachments.append({
                "file_id": file_id,
                "filename": file_name,
            })

    if existing_task_id:
        print(f"Continuing existing task {existing_task_id} for thread {thread_id}")
        create_manus_task(prompt_text, task_id=existing_task_id,attachments=manus_attachments)
        
        client.reactions_add(
            channel=channel_id,
            name="eyes",
            timestamp=event["ts"]
        )
        return
        
    # --- Create the task with the prompt and any attachments ---
    manus_task = create_manus_task(prompt_text, attachments=manus_attachments)
    new_task_id = manus_task.get("task_id")
    # ... (rest of the function remains the same)
```

With this new change, you should be able to respond to the user's message, upload the file to Manus, and then create a new task with the prompt and attachments.

Our bot can now receive and understand vacation claims submitted via Slack. But what happens next? We'll need to create a system to process these claims and notify the appropriate team members.

Our bot can now receive and understand vacation claims submitted via Slack. But what happens next? A truly intelligent agent doesn't just pass information along; it needs to understand company policies and interact with other business systems. This is where Manus Connectors come in.

## Using Connectors

To process an expense claim correctly, our bot needs two things:

1. Access to Knowledge: It must know the current company travel and expense policy to validate the claim.
2. A Place to Record Data: It needs to log the approved claim in a structured way for the finance team.


For this, we'll use a central Notion database. Manus Connectors allow the agent to securely read from and write to your external tools, giving it the long-term memory and skills it needs to perform complex tasks. 

We have already pre-configured a Notion connector with the ID 9c27c684-2f4f-4d33-8fcf-51664ea15c00. 

By simply providing this ID when we create a task, we grant Manus access to the necessary resources it needs to process the claim and log it in the Notion database.

## System Prompt

With file handling and Notion access in place, the final piece is telling the agent exactly what to do.

We will now update our create_manus_task function with a detailed prompt that outlines the agent's precise workflow. 

```py
def create_manus_task(prompt: str, task_id: Optional[str] = None, attachments: Optional[list[FileIDAttachment]] = None) -> dict:
    api_key = os.environ["MANUS_API_KEY"]
    base_url = "https://api.manus.ai/v1"
    
    # This is our master instruction set for the agent.
    system_prompt = f"""
You're a helpful assistant for company policy questions. Your goal is to process employee expense claims accurately and efficiently.

Follow these steps precisely:
1.  **Consult the Knowledge Base**: Always use the attached Notion connector to retrieve the most up-to-date version of the company expense policy before answering.
2.  **Analyze and Validate**: Review the user's request and any attached files (like receipts). Compare the claim against the company policy you just retrieved.
3.  **Provide a Clear Answer**: Respond to the user's question, providing inline citations from the policy document to justify your answer.
4.  **Update the Database**: If the claim is valid, create a new, structured entry in the "Expense Claims" Notion database. Extract key information like vendor, date, amount, and expense category from the receipt.

<user_request>
{prompt}
</user_request>
    """
    
    payload = {
        "prompt": system_prompt,
        "agentProfile": "manus-1.5",
        "taskMode": "agent",
        # This is where we activate our Notion connector
        "connectors": ["9c27c684-2f4f-4d33-8fcf-51664ea15c00"] 
    }
    
    if task_id:
        payload["taskId"] = task_id
    
    if attachments:
        payload["attachments"] = attachments

    response = requests.post(
        f"{base_url}/tasks",
        headers={"API_KEY": api_key},
        json=payload,
    )
    response.raise_for_status()
    return response.json()
```

## Conclusion

Congratulations! You've just built a sophisticated, end-to-end business automation solution that ties together everything you've learned. This isn't just a chatbot; it's an intelligent agent that can see, read, reason, and interact with your team's most important tools.

Let's recap the journey:

1. Notebook 1: You mastered the fundamentals of creating and managing asynchronous tasks.
2. Notebook 2: You learned to provide rich context by attaching files, enabling complex data analysis.
3. Notebook 3: You replaced inefficient polling with a professional, event-driven architecture using webhooks.
4. Notebook 4: You built a robust, conversational Slack bot capable of handling multi-turn interactions.


At the end of it all, you combined all these skills to create a slack bot that's integrated with a fictional company claims policy and can handle expense claims. 


